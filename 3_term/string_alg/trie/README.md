# Задача о поиске вхождений шаблона с масками в текст (Contest1-Task3)
Дан текст длины **n** и шаблон с масками (т.е. знаками *?*) длины **m**, 
гарантируется, что знак *?* в тексте не встречается. Необходимо найти все позиции
вхождений этого шаблона в текст (т.е. все обычные символы шаблона совпадают с символами
текста, а на местах с *?* могут стоять произвольные символы).
### Как будем решать?
Построим автомат Ахо-Корасик на подстроках из шаблона в которых нет *?* (в программе за парсинг шаблона отвечает 
функция **ParseTemplate**). Далее будем идти по данному тексту и менять состояния нашего автомата,
для каждого состояния проверяя является ли какой-то суффикс строки, за которую отвечает текущая вершина, терминальным 
(за это отвечает функция **CheckIfAnySuffixIsTerminal**). Если находим терминальную вершину, то в массив
**possible_starts_of_template** будем добавлять 1 на место **starting_pos_of_template_in_text - starting_pos_in_template**, 
где  **starting_pos_of_template_in_text** - это позиция, которой встречается наш найденный шаблон в тексте, а **starting_pos_in_template** - 
это позиция на которой данный строка встречалась в нашем шаблоне. Тогда после того как мы пройдем весь текст, на тех позцииях,
где мог начинаться наш исходный шаблон в массиве **possible_starts_of_template** значения будут равны количеству подстрок шаблона 
без *?*.
##### Примечание
Вместо того чтобы возвращать какую-то СД, которая содержит позиции 
вхождений строк, полученных в результате парсинга шаблона, в текстe, обобщим реализацию с помощью обработки найденных терминальных вершинок
функцией **Visit**, это позволит сразу считать позиции, на которых теоритически мог бы встречаться наш
исходный шаблон.

### Построение Автомата Ахо-Корасик

После парсинга шаблона, полученные строки необходимо добавить в бор с помощью функции Add. Добавление работает примитивно —
пытаемся переходить по ребрам уже построенного бора, читая буквы нашей строки последовательно, когда по какой-то букве 
перехода нет, добавляем ребро с буквой, по которой прошли.

**Опр.** Суффиксной ссылкой из вершины бора ***v*** назовем ребро в какую-то другую вершину ***u***, которой соотвествует строка 
являющаяся наибольшим (по длине) суффиксом строки, соответсвовавшей вершине ***v***. (В случае если суффиксов строки вершины ***v*** 
в боре нет суффиксная ссылка указывает в корень бора).

##### Как ее можно попробовать вычислить?
Пусть мы хотим попробовать понять в какую вершину ведет суф. ссылка из веришны ***v***, 
если предположить что для всех вершин выше по дереву мы уже корректно посчитали суф. ссылки, то можно сделать следующее –
посмотреть по какому символу мы пришли в ***v*** из его родителя ***u*** (пусть это ***b***), взять суф. ссылку вершины ***u***
(так как мы уже предположили, что все суф. ссылки выше посчитали, то это корректно) и потом попробовать продлить то слово вершины, 
в которую попадем, символом ***b***, и если не получится, то повторим эту операцию для этой новой вершины. Стоит заметит, 
что при переходе по суф.ссылке длина слова, соотвествующего нашему состоянию уменьшается, а следовательно, 
если действительно мы имеем посчитанные суф. ссылки для всех вершин расстояние до корня от которых меньше текущего, 
то такая операция будет корректна.

**Опр.** Сжатой суффиксной ссылкой назовем суффиксную ссылку, которая ведет в терминальную веришну. (Будут использовать
для быстрого определения есть ли у строки текущего состояния терминальные суффиксы, потому что если сжатая суффиксная ссылка 
ведет в корень, то никаких терминальных суффиксов у нее очевидно нет).

Ни суффиксные ссылки, ни сжатые суффиксные ссылки при построении бора не строю, а делаю это уже при непосредственном
чтении текста. (В программе за получение суффиксной ссылки от вершины отвечает фукнция **GetSuffixLink**, за получение сжатой
суф.ссылки – **GetCompressedSuffixLink**)

### Зачем нужны суффиксные ссылки?

Суффиксные ссылки нужны для правильных переходов по автомату в случае если из текущей вершины нет перехода по какой-то новой 
прочитанной букве текста. В данном случае нам необходимо перейти в суффиксную ссылку текущей веришнины автомата и посмотреть 
нет ли из нее перехода по новому символу. Так мы приходим к появлению такого понятия как функция перехода.

Вместо формального определения проще объяснить как она строится, так будет проще и понятнее. Рассмотрим случаи как посчитать значение 
функции перехода для вершины ***v*** по символу ***a***

1. Пусть из вершины ***v*** есть ребро по символу ***a*** в какую-то вершину ***u***, тогда фукнция вернет ***u***;
2. Если из вершины нет ребра по символу ***a*** и при этом такая вершина является корневой, тогда функция перехода вернет ***v***;
3. Если из вершины нет ребра по символу ***a*** и при этом и она не корневая, то ее значение можно вычислить рекурсивно, 
в предположении что для всех вершин до которых расстояние от корня меньше мы уже посчитали фукнцию перехода. Тогда она будет равна 
значению функциии перехода от вершины, в которую мы приходим по суф. ссылке из вершины ***v***, по символу ***a***.


Как ни странно теперь зная функцию перехода мы можем совсем просто через нее рекурсивно определить и операцию 
получения суф. ссылки от вершины, а именно: значение суф. ссылки от нашей вершины ***v*** с родителем ***u*** из которого мы пришли по символу ***a***,
 равно значению функции перехода от суф. ссылки вершины ***u*** по символу ***a***.
 
Таким образом мы получили взаимное выражение операций получения суф. ссылки и функции перехода через друг друга, 
что поможет нам легко их вычислять. Что же касается части реализации, то для хранения значений уже посчитанных фукнций перехода, 
суф. ссылок, сжатых суф. ссылок в структуре **Vertex** я храню такие поля как статический массив  **go_**, 
и два целочисленных значения **suffix_link_**, **comp_suffix_link_**.

##### Примечание 
Конечно же построив бор можно сразу посчитать все суф. ссылки, сжатые суф. ссылки и массив go обходом в ширину от корня, 
но я решил, что выгоднее делать это при проходе по тексту, так как некоторые значения вполне могут и не пригодиться.



### Построение сжатых суффиксных ссылок 

Для того чтобы улучшить асимтотику алгоритма мы используем сжатые суффиксные ссылки, выше уже было дано определение 
этого понятия. В принципе, зная определение и посчитав суф. ссылки легко понять как рекурсивно считать и сжатые. Сжатая ссылка равна
1. Корню, если обычная суф. ссылка ведет в корень;
2. Значению суф. ссылки из этой вершины, если суф. ссылка ведет в терминальную вершину;
3. Иначе она равна значению функции возвращающей сжатую суф. ссылку примененной к суф. ссылке этой вершины.

### Асимптотика

1. Построение бора – не более чем за сумму длинн строк бора, то есть не больше чем за длину шаблона т.е. **O(m)**
2. Построение суф. ссылок, сжатых суф. ссылок и массива **go_** все идет в **O(m)**
3. Проход по тексту и проверка возможной терминальности суффиксов строки соответствующей каждой вершине не больше 
**O(n + ans)**, где  ans – общее число вхождений подстрок шаблона между масками в исходном тексте.

***Итог: O(n + m + ans)***


